//! Portal Descriptor v1 - Static deployment descriptor for service discovery
//!
//! The descriptor is the source of truth for what services the portal displays.
//! It is generated by Pulumi and injected into the portal container.
//!
//! This module is a thin wrapper around the generated types from descriptor_gen.rs,
//! adding only runtime concerns:
//! - Size guard for environment variable source
//! - Source selection (env var vs file)
//! - Safe error formatting
//!
//! Contract rules:
//! - Non-secret: no client secrets, passwords, or tokens
//! - All URLs are public, absolute, with explicit scheme (http:// or https://)
//! - Services array order is the display order
//! - Strict mode: unknown fields are rejected

// Re-export generated types
pub use super::descriptor_gen::{AuthType, Descriptor, KeycloakConfig, PortalConfig, Service};

/// Supported descriptor versions
const SUPPORTED_VERSIONS: &[&str] = &["1"];

/// Maximum descriptor size when loaded from environment variable (64KB)
const MAX_ENV_DESCRIPTOR_SIZE: usize = 64 * 1024;

// ============================================================================
// Legacy type aliases for backwards compatibility
// ============================================================================

/// Alias for Service (legacy name)
pub type ServiceDescriptor = Service;

/// Alias for PortalConfig (legacy name)
pub type PortalDescriptor = PortalConfig;

/// Alias for KeycloakConfig (legacy name)
pub type KeycloakDescriptor = KeycloakConfig;

// ============================================================================
// Error types and source tracking (runtime concerns)
// ============================================================================

/// Source of the descriptor for error reporting
#[derive(Debug, Clone, Copy)]
pub enum DescriptorSource {
    EnvJson,
    FilePath,
}

impl std::fmt::Display for DescriptorSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescriptorSource::EnvJson => write!(f, "PORTAL_DESCRIPTOR_JSON"),
            DescriptorSource::FilePath => write!(f, "PORTAL_DESCRIPTOR_PATH"),
        }
    }
}

/// Descriptor loading error with actionable context
#[derive(Debug)]
pub struct DescriptorError {
    pub source: DescriptorSource,
    pub message: String,
    pub field_path: Option<String>,
}

impl std::fmt::Display for DescriptorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Failed to load descriptor from {}", self.source)?;
        if let Some(ref path) = self.field_path {
            write!(f, " at {}", path)?;
        }
        write!(f, ": {}", self.message)
    }
}

impl std::error::Error for DescriptorError {}

// ============================================================================
// Loading and parsing (runtime concerns)
// ============================================================================

impl Descriptor {
    /// Parse descriptor from JSON string with size guard
    pub fn from_json_with_source(
        json: &str,
        source: DescriptorSource,
    ) -> Result<Self, DescriptorError> {
        // Size guard for env var source
        if matches!(source, DescriptorSource::EnvJson) && json.len() > MAX_ENV_DESCRIPTOR_SIZE {
            return Err(DescriptorError {
                source,
                message: format!(
                    "descriptor size ({} bytes) exceeds maximum for environment variable ({} bytes). \
                     Use PORTAL_DESCRIPTOR_PATH instead.",
                    json.len(),
                    MAX_ENV_DESCRIPTOR_SIZE
                ),
                field_path: None,
            });
        }

        serde_json::from_str(json).map_err(|e| {
            // Extract field path from serde error if available
            let field_path = extract_field_path(&e);
            DescriptorError {
                source,
                message: e.to_string(),
                field_path,
            }
        })
    }

    /// Parse descriptor from JSON file
    pub fn from_file(path: &str) -> Result<Self, DescriptorError> {
        let content = std::fs::read_to_string(path).map_err(|e| DescriptorError {
            source: DescriptorSource::FilePath,
            message: format!("failed to read file '{}': {}", path, e),
            field_path: None,
        })?;

        Self::from_json_with_source(&content, DescriptorSource::FilePath)
    }

    /// Validate the descriptor version for forward compatibility
    ///
    /// This is intentionally minimal - the producer (Pulumi) validates all schema
    /// rules using Ajv. The consumer only needs to check:
    /// - Version compatibility (reject unknown versions)
    /// - Size guard (handled in from_json_with_source)
    /// - Strict JSON parsing (handled by serde's deny_unknown_fields)
    pub fn validate(&self) -> Result<(), String> {
        if !SUPPORTED_VERSIONS.contains(&self.version.as_str()) {
            return Err(format!(
                "unsupported descriptor version '{}' (supported: {})",
                self.version,
                SUPPORTED_VERSIONS.join(", ")
            ));
        }
        Ok(())
    }

    /// Get a summary of the descriptor for logging (no sensitive data)
    pub fn summary(&self) -> DescriptorSummary {
        let protected_count = self.services.iter().filter(|s| s.protected).count();
        let public_count = self.services.len() - protected_count;

        DescriptorSummary {
            deployment_id: self.deployment_id.clone(),
            environment: self.environment.clone(),
            base_domain: self.base_domain.clone(),
            portal_url: self.portal.public_url.clone(),
            keycloak_url: self.keycloak.public_url.clone(),
            total_services: self.services.len(),
            protected_services: protected_count,
            public_services: public_count,
        }
    }
}

/// Summary of descriptor for logging (non-sensitive)
#[derive(Debug)]
pub struct DescriptorSummary {
    pub deployment_id: String,
    pub environment: String,
    pub base_domain: String,
    pub portal_url: String,
    pub keycloak_url: String,
    pub total_services: usize,
    pub protected_services: usize,
    pub public_services: usize,
}

impl std::fmt::Display for DescriptorSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "deploymentId={}, environment={}, baseDomain={}, portal={}, keycloak={}, services={} ({} protected, {} public)",
            self.deployment_id,
            self.environment,
            self.base_domain,
            self.portal_url,
            self.keycloak_url,
            self.total_services,
            self.protected_services,
            self.public_services
        )
    }
}

/// Extract field path from serde_json error if available
fn extract_field_path(e: &serde_json::Error) -> Option<String> {
    // serde_json errors include line/column but not always field path
    // For now, we include line/column info which helps locate the issue
    let line = e.line();
    let col = e.column();
    if line > 0 {
        Some(format!("line {} column {}", line, col))
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_descriptor_json() -> &'static str {
        r#"{
            "version": "1",
            "deploymentId": "local",
            "environment": "dev",
            "baseDomain": "localhost",
            "portal": {
                "publicUrl": "http://localhost"
            },
            "keycloak": {
                "publicUrl": "http://keycloak.localhost",
                "issuerUrl": "http://keycloak.localhost/realms/dev",
                "realm": "dev"
            },
            "services": [
                {
                    "id": "demo",
                    "name": "Demo App",
                    "url": "http://demo.localhost",
                    "protected": true,
                    "authType": "oauth2-proxy",
                    "icon": "rocket",
                    "description": "Demo application",
                    "requiredRealmRoles": ["admin", "dev"]
                },
                {
                    "id": "docs",
                    "name": "Documentation",
                    "url": "http://docs.localhost",
                    "protected": false,
                    "authType": "none"
                }
            ]
        }"#
    }

    #[test]
    fn test_parse_descriptor() {
        let descriptor =
            Descriptor::from_json_with_source(sample_descriptor_json(), DescriptorSource::EnvJson)
                .unwrap();
        assert_eq!(descriptor.version, "1");
        assert_eq!(descriptor.deployment_id, "local");
        assert_eq!(descriptor.services.len(), 2);
        assert_eq!(descriptor.services[0].id, "demo");
        assert_eq!(descriptor.services[0].auth_type, AuthType::Oauth2Proxy);
        assert_eq!(descriptor.services[1].auth_type, AuthType::None);
    }

    #[test]
    fn test_validate_descriptor_version() {
        // Valid version passes
        let descriptor =
            Descriptor::from_json_with_source(sample_descriptor_json(), DescriptorSource::EnvJson)
                .unwrap();
        assert!(descriptor.validate().is_ok());
    }

    #[test]
    fn test_validate_unsupported_version() {
        let json = r#"{
            "version": "2",
            "deploymentId": "local",
            "environment": "dev",
            "baseDomain": "localhost",
            "portal": { "publicUrl": "http://localhost" },
            "keycloak": {
                "publicUrl": "http://keycloak.localhost",
                "issuerUrl": "http://keycloak.localhost/realms/dev",
                "realm": "dev"
            },
            "services": []
        }"#;
        let descriptor =
            Descriptor::from_json_with_source(json, DescriptorSource::EnvJson).unwrap();
        let error = descriptor.validate().unwrap_err();
        assert!(error.contains("unsupported descriptor version '2'"));
        assert!(error.contains("supported: 1"));
    }

    #[test]
    fn test_reject_unknown_fields() {
        // serde's deny_unknown_fields rejects unknown properties
        let json = r#"{
            "version": "1",
            "deploymentId": "local",
            "environment": "dev",
            "baseDomain": "localhost",
            "unknownField": "should fail",
            "portal": { "publicUrl": "http://localhost" },
            "keycloak": {
                "publicUrl": "http://keycloak.localhost",
                "issuerUrl": "http://keycloak.localhost/realms/dev",
                "realm": "dev"
            },
            "services": []
        }"#;
        let result = Descriptor::from_json_with_source(json, DescriptorSource::EnvJson);
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(err.message.contains("unknown field"));
    }

    #[test]
    fn test_descriptor_summary() {
        let descriptor =
            Descriptor::from_json_with_source(sample_descriptor_json(), DescriptorSource::EnvJson)
                .unwrap();
        let summary = descriptor.summary();
        assert_eq!(summary.deployment_id, "local");
        assert_eq!(summary.total_services, 2);
        assert_eq!(summary.protected_services, 1);
        assert_eq!(summary.public_services, 1);
    }

    #[test]
    fn test_size_guard_for_env_var() {
        // Create a JSON that exceeds the limit
        let large_json = format!(
            r#"{{
            "version": "1",
            "deploymentId": "local",
            "environment": "dev",
            "baseDomain": "localhost",
            "portal": {{ "publicUrl": "http://localhost" }},
            "keycloak": {{
                "publicUrl": "http://keycloak.localhost",
                "issuerUrl": "http://keycloak.localhost/realms/dev",
                "realm": "dev"
            }},
            "services": [],
            "padding": "{}"
        }}"#,
            "x".repeat(MAX_ENV_DESCRIPTOR_SIZE + 1000)
        );

        let result = Descriptor::from_json_with_source(&large_json, DescriptorSource::EnvJson);
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(err.message.contains("exceeds maximum"));
        assert!(err.message.contains("PORTAL_DESCRIPTOR_PATH"));
    }

    #[test]
    fn test_error_message_format() {
        let json = r#"{ "version": "1" }"#; // Missing required fields
        let result = Descriptor::from_json_with_source(json, DescriptorSource::EnvJson);
        assert!(result.is_err());
        let err = result.unwrap_err();
        // Error should mention the source
        let display = format!("{}", err);
        assert!(display.contains("PORTAL_DESCRIPTOR_JSON"));
    }
}
