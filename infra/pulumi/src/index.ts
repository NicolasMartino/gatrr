/**
 * Pulumi entry point for portal infrastructure
 *
 * This program manages the complete deployment:
 * - Docker network
 * - Traefik reverse proxy (with file provider config)
 * - Keycloak (OAuth2/OIDC provider)
 * - Portal (service dashboard)
 * - User services (via service modules)
 *
 * Architecture: Deployment-config-driven
 * - Deployment config (deployment.<stack>.json) is the source of truth
 * - Service modules are factories in the catalog
 * - Only services listed in deployment config are deployed
 * - Roles and users come from deployment config
 *
 * Secrets model (per plan.md):
 * - Operational secrets (admin credentials) are provided via Pulumi config
 * - Deployment secrets (client secrets, cookie secrets) are GENERATED by Pulumi
 * - Generated secrets are persisted in Pulumi state (encrypted)
 * - Subsequent deploys reuse the same secrets; rotation is explicit
 */

import * as pulumi from "@pulumi/pulumi";
import * as path from "path";
import { getConfig, buildUrl } from "./config";
import { ServiceContext, ServiceModuleResult, RouteRequest, shortName } from "./types";
import { generateDescriptor } from "./descriptor/index";
import { createNetwork } from "./network";
import { createTraefik } from "./traefik";
import { createKeycloak, buildClientRequest } from "./keycloak";
import { createPortal } from "./portal";
import { buildPortalImage } from "./images";
import { generateDeploymentSecrets, GeneratedSecrets } from "./secrets";

// Import deployment config module
import {
  loadDeploymentConfigFile,
  resolveDeploymentConfig,
  assertValidDeploymentConfig,
  getProtectedServiceIdsFromConfig,
  getProtectedServices,
  UserConfig,
} from "./deployment-config";

// Import unified users module
import {
  parseUnifiedUsersYaml,
  resolveUnifiedUser,
} from "./deployment-config/unified-users";

// Import service catalog
import {
  getAvailableServiceIds,
  getServiceFactory,
  deriveAuthzPolicies,
} from "./services";

// Compute repo root from this file's location (infra/pulumi/src/index.ts -> repo root)
const repoRoot = path.resolve(__dirname, "../../..");

// =============================================================================
// DEPLOYMENT CONFIG
// =============================================================================

// Load stack configuration (Pulumi.yaml + Pulumi.<stack>.yaml)
const config = getConfig();

// Load and resolve deployment config from deployment.<stack>.json
const stackName = pulumi.getStack();
const rawDeploymentConfig = loadDeploymentConfigFile(stackName);
const deploymentConfig = resolveDeploymentConfig(stackName, rawDeploymentConfig);

// Validate deployment config before creating any resources
// This will throw with actionable errors if config is invalid
assertValidDeploymentConfig(deploymentConfig, getAvailableServiceIds());

// =============================================================================
// SECRETS
// =============================================================================

// Operational secrets (provided via Pulumi config - these are human-managed)
const secretsConfig = new pulumi.Config("secrets");
const keycloakAdminUsername = secretsConfig.requireSecret("keycloakAdminUsername");
const keycloakAdminPassword = secretsConfig.requireSecret("keycloakAdminPassword");

// Deployment secrets (GENERATED by Pulumi, persisted in state)
// These are generated once on first deploy and reused on subsequent deploys.
// Per plan.md: "Client secrets are generated once by Pulumi on first creation
// and persisted (encrypted) in Pulumi state/config backend."
//
// Protected service IDs are derived from deployment config (not hardcoded).
const protectedServiceIds = getProtectedServiceIdsFromConfig(deploymentConfig);
const generatedSecrets: GeneratedSecrets = generateDeploymentSecrets(config.deploymentId, protectedServiceIds);

// =============================================================================
// INFRASTRUCTURE
// =============================================================================

// Create Docker network
const { network } = createNetwork(config);

// Compute Keycloak issuer URLs deterministically
// This allows services to be created before Keycloak while still having the correct URLs.
const keycloakContainerName = shortName(config.deploymentId, "keycloak");
// Internal URL: used in dev (Keycloak not resolvable via public DNS from within Docker)
const keycloakInternalIssuerUrl = `http://${keycloakContainerName}:8080/realms/${config.keycloakRealm}`;
// Public URL: used in prod (matches what Keycloak advertises in tokens)
const keycloakPublicIssuerUrl = `${buildUrl(config, "keycloak")}/realms/${config.keycloakRealm}`;

// Build service context for service modules
const serviceContext: ServiceContext = {
  config,
  network,
  keycloakInternalIssuerUrl,
  keycloakPublicIssuerUrl,
  oauth2ProxyCookieSecret: generatedSecrets.oauth2ProxyCookieSecret,
};

// =============================================================================
// SERVICES (from deployment config)
// =============================================================================

/**
 * Create services based on deployment config
 *
 * Only services listed in deployment config are created.
 * Service factories come from the catalog.
 */
function createDeployedServices(
  context: ServiceContext,
  clientSecrets: Record<string, pulumi.Input<string>>
): ServiceModuleResult[] {
  const results: ServiceModuleResult[] = [];

  for (const service of deploymentConfig.services) {
    const factory = getServiceFactory(service.serviceId);
    if (!factory) {
      // Should never happen if validation passed
      throw new Error(
        `No factory found for service "${service.serviceId}". ` +
        `This should have been caught by validation.`
      );
    }

    // Protected services need client secrets
    const needsSecret = service.authType === "oauth2-proxy";
    const clientSecret = needsSecret ? clientSecrets[service.serviceId] : undefined;

    if (needsSecret && !clientSecret) {
      throw new Error(
        `Service "${service.serviceId}" requires oauth2-proxy but no client secret was provided`
      );
    }

    const result = factory({
      context,
      clientSecret,
    });

    results.push(result);
  }

  return results;
}

// Create services from deployment config
const serviceModules: ServiceModuleResult[] = createDeployedServices(
  serviceContext,
  generatedSecrets.serviceClientSecrets
);

// Derive authorization policies from service module results
const authzPolicies = deriveAuthzPolicies(serviceModules);

// Build Keycloak client requests from protected services in deployment config
const protectedServices = getProtectedServices(deploymentConfig);
const clientRequests = protectedServices.map((svc) =>
  buildClientRequest(config, svc.serviceId)
);

// =============================================================================
// UNIFIED USERS (from Pulumi secrets)
// =============================================================================

// Users are defined entirely in Pulumi secrets (unified format).
// The secrets:unifiedUsers secret contains a YAML array of users with:
// - username, password (required)
// - email, firstName, lastName, roles (optional, defaults applied)

const unifiedUsersYaml = secretsConfig.requireSecret("unifiedUsers");

// Parse and resolve unified users
// This is done inside pulumi.output().apply() because the secret is encrypted
const resolvedUsersOutput = unifiedUsersYaml.apply((yamlStr) => {
  const parsedUsers = parseUnifiedUsersYaml(yamlStr);
  return parsedUsers.map((u) => resolveUnifiedUser(u, stackName));
});

// Build UserConfig array for Keycloak (without passwords)
// and userPasswords map (passwords only)
// These maintain compatibility with the existing Keycloak module interface
const usersForKeycloak = resolvedUsersOutput.apply((users) =>
  users.map((u): UserConfig => ({
    username: u.username,
    email: u.email,
    firstName: u.firstName,
    lastName: u.lastName,
    roles: u.roles,
  }))
);

const userPasswords = resolvedUsersOutput.apply((users) =>
  Object.fromEntries(users.map((u) => [u.username, u.password]))
);

// Also compute roles from users for deployment config
const userRoles = resolvedUsersOutput.apply((users) => {
  const roles = new Set<string>();
  for (const user of users) {
    for (const role of user.roles) {
      roles.add(role);
    }
  }
  return Array.from(roles).sort();
});

// =============================================================================
// KEYCLOAK
// =============================================================================

// Build deployment config with users from unified secrets
// Users now come entirely from Pulumi secrets, not deployment JSON
const deploymentConfigWithUsers = pulumi
  .all([usersForKeycloak, userRoles])
  .apply(([users, roles]) => ({
    ...deploymentConfig,
    users,
    // Merge roles from users with roles from deployment config
    roles: Array.from(new Set([...deploymentConfig.roles, ...roles])).sort(),
  }));

// Create Keycloak with unified users
const keycloak = createKeycloak({
  config,
  network,
  portalClientSecret: generatedSecrets.portalClientSecret,
  oauth2ProxyClientSecrets: generatedSecrets.serviceClientSecrets,
  adminUsername: keycloakAdminUsername,
  adminPassword: keycloakAdminPassword,
  deploymentConfig: deploymentConfigWithUsers,
  userPasswords,
  clientRequests,
  authzPolicies,
});

// Collect all routes from service modules
const allRoutes: RouteRequest[] = serviceModules.flatMap((m) => m.routes);

// Create Traefik with routes from service modules
const traefik = createTraefik({
  config,
  routes: allRoutes,
  network,
});

// =============================================================================
// PORTAL
// =============================================================================

// Collect portal services from service modules
const portalServices = serviceModules.map((m) => m.portal);

// Generate portal descriptor from service module outputs
const descriptor = generateDescriptor(config, portalServices);

// Build portal Docker image
const portalImage = buildPortalImage({
  deploymentId: config.deploymentId,
  contextPath: repoRoot,
  platform: config.buildPlatform,
});

// Create Portal
const portal = createPortal({
  config,
  network,
  descriptor,
  keycloakInternalUrl: keycloak.internalUrl,
  clientId: "portal",
  clientSecret: generatedSecrets.portalClientSecret,
  image: portalImage.imageName,
});

// =============================================================================
// EXPORTS (Stack Outputs)
// =============================================================================

// Primary outputs - these are the main URLs users need to access the deployment
export const portalUrl = portal.publicUrl;
export const keycloakUrl = keycloak.publicUrl;

// Deployment metadata - useful for CI/CD and debugging
export const deployment = {
  id: config.deploymentId,
  environment: config.environment,
  baseDomain: config.baseDomain,
  serviceCount: serviceModules.length,
  deployedServices: deploymentConfig.services.map((s) => s.serviceId),
};

// Container names - useful for docker commands and debugging
export const containers = {
  traefik: traefik.container.name,
  keycloak: keycloak.container.name,
  portal: portal.container.name,
  services: serviceModules.map((m) => ({
    id: m.id,
    container: m.resources.container.name,
    oauth2Proxy: m.resources.oauth2ProxyContainer?.name,
  })),
};
